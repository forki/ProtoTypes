namespace ProtoTypes.Generation

open Microsoft.FSharp.Quotations

open ProtoTypes.Core
open ProviderImplementation.ProvidedTypes

open Froto.Parser.Model
open Froto.Core
open Froto.Core.Encoding

/// Contains an implementation of serialization method for types generated from ProtoBuf messages
[<RequireQualifiedAccess>]
module Serialization = 
        
    /// Creates an expression that serializes all given properties to the given instance of ZeroCopyBuffer
    let private serializeProperty (prop: ProtoPropertyInfo) buffer this =
    
        let value = Expr.PropertyGet(this, prop.ProvidedProperty)
        let position = prop.ProtoField.Position
        
        // writer is an expression that represents a function 'T -> unit for any primitive or enum field of type 'T.
        // For embedded messages, writer will have type Message -> unit. It's caused by the fact that it's not possible to pass
        // any generic arguments including option<'T> and 'T -> unit to other functions if 'T is generated by a type provider.
        let writer =
            match prop.TypeKind with
                | Primitive -> 
                    match prop.UnderlyingType with
                    | t when t = typeof<int> -> <@@ Codec.writeInt32 position %%buffer@@>
                    | t when t = typeof<string> -> <@@ Codec.writeString position %%buffer @@>
                    | t when t = typeof<float> -> <@@ Codec.writeDouble position %%buffer @@>
                    | t when t = typeof<bool> -> <@@ Codec.writeBool position %%buffer @@>
                    | x -> notsupportedf "Primitive type '%s' is not supported" x.Name
                | Class -> <@@ Codec.writeEmbedded position %%buffer @@>
                | Enum -> <@@ Codec.writeInt32 position %%buffer @@>
                
        let write f value = Expr.callStaticGeneric [prop.UnderlyingType] [writer; value] f

        try
            match prop.ProtoField.Rule with
            | Required -> Expr.Application(writer, value)
            | Optional ->
                match prop.TypeKind with
                | Class -> write <@@ Codec.writeOptionalEmbedded x x @@> <| Expr.Coerce(value, typeof<obj>)
                | _ -> write <@@ Codec.writeOptional x x @@> value
            | Repeated ->
                match prop.TypeKind with
                | Class -> write <@@ Codec.writeRepeatedEmbedded x x @@> <| Expr.Coerce(value, typeof<obj>)
                | _ -> write <@@ Codec.writeRepeated x x @@> value
        with
        | ex -> 
            printfn "Failed to serialize property %s: %O. Error: %O" prop.ProvidedProperty.Name value.Type ex
            reraise()
            
    let serializeExpr properties buffer this =
        let serializeProperties = 
            properties
            |> List.sortBy (fun prop -> prop.ProtoField.Position)
            |> List.map (fun prop -> serializeProperty prop buffer this)
            |> Expr.sequence 

        Expr.Sequential(serializeProperties, buffer)